{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Reflector Docs \u00b6 Some stuff here.","title":"Reflector Docs"},{"location":"#reflector-docs","text":"Some stuff here.","title":"Reflector Docs"},{"location":"internals/architecture/","text":"Architecture \u00b6 The reflector works in three major parts: A syncing watcher component A syncing endpoint component Syncer \u00b6 The syncer runs through the following process on startup: The syncer fetches a list of namespaces and secrets that it has access to If sharding is enabled, the syncer will If sharding is enabled, the syncer will then collect the secrets it is chosen to watch over The syncer will set a watch on all the namespaces it has access to for new secrets that come into existence If a new secret comes into being, and sharding is enabled, the syncer will consult its partition key as to whether it should watch it Once the syncer is watching the namespaces, it will walk the namespaces and check for any secret with relevant annotations reflector.havulv.io/* Additionally, when sharding, the syncer will add an annotation to establish ownership of the secret (and a healthcheck ttl): reflector.havulv.io/checked-by: \"${pod-hash} (${UNIX TIMESTAMP}) You can tune the healthcheck ttl on the command line via --shard-ttl After gathering all the secrets, the syncer will establish a tree of secrets and prune any secrets it doesn't need (e.g. if sharding is activated) Once the syncer is watching a specific secret, it will do the following on various events: On Delete \u00b6 If the --cascade-deletion flag is set, then the syncer will delete all of the synced secrets. On Change \u00b6 On change, the secret syncer will read the reflector.havulv.io/namespaces and look for any reflector.havulv.io/reflect: true annotations in order to establish which namespaces the secret should be copied to. Each namespace should be separated by a comma. If the field is empty then no action will be taken. If the field is * then all namespaces will be reflected to. So, to summarize: * \"this,that\" will reflect to the namespaces this and that * \"*\" will reflect to all namespaces * \"\" will reflect to no namespaces The syncer will then create the reflected secrets in the specified namespaces, adding the following annotations and labels: Labels : * reflector.havulv.io/reflected: true Annotations : * reflector.havulv.io/reflected-from: ${namespace the secret was reflected from} * reflector.havulv.io/reflected-at: ${Unix timestamp of when the secret was reflected} * reflector.havulv.io/hash: ${hash sum of the secret to speed up comparisons}","title":"Architecture"},{"location":"internals/architecture/#architecture","text":"The reflector works in three major parts: A syncing watcher component A syncing endpoint component","title":"Architecture"},{"location":"internals/architecture/#syncer","text":"The syncer runs through the following process on startup: The syncer fetches a list of namespaces and secrets that it has access to If sharding is enabled, the syncer will If sharding is enabled, the syncer will then collect the secrets it is chosen to watch over The syncer will set a watch on all the namespaces it has access to for new secrets that come into existence If a new secret comes into being, and sharding is enabled, the syncer will consult its partition key as to whether it should watch it Once the syncer is watching the namespaces, it will walk the namespaces and check for any secret with relevant annotations reflector.havulv.io/* Additionally, when sharding, the syncer will add an annotation to establish ownership of the secret (and a healthcheck ttl): reflector.havulv.io/checked-by: \"${pod-hash} (${UNIX TIMESTAMP}) You can tune the healthcheck ttl on the command line via --shard-ttl After gathering all the secrets, the syncer will establish a tree of secrets and prune any secrets it doesn't need (e.g. if sharding is activated) Once the syncer is watching a specific secret, it will do the following on various events:","title":"Syncer"},{"location":"internals/architecture/#on-delete","text":"If the --cascade-deletion flag is set, then the syncer will delete all of the synced secrets.","title":"On Delete"},{"location":"internals/architecture/#on-change","text":"On change, the secret syncer will read the reflector.havulv.io/namespaces and look for any reflector.havulv.io/reflect: true annotations in order to establish which namespaces the secret should be copied to. Each namespace should be separated by a comma. If the field is empty then no action will be taken. If the field is * then all namespaces will be reflected to. So, to summarize: * \"this,that\" will reflect to the namespaces this and that * \"*\" will reflect to all namespaces * \"\" will reflect to no namespaces The syncer will then create the reflected secrets in the specified namespaces, adding the following annotations and labels: Labels : * reflector.havulv.io/reflected: true Annotations : * reflector.havulv.io/reflected-from: ${namespace the secret was reflected from} * reflector.havulv.io/reflected-at: ${Unix timestamp of when the secret was reflected} * reflector.havulv.io/hash: ${hash sum of the secret to speed up comparisons}","title":"On Change"}]}